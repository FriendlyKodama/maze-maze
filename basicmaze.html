<!-- Standalone basic maze using HTML Canvas-->

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>maze maze</title>
    <script type="text/javascript">
      const TILE_SIZE = 30;
      const TOP_MARGIN = 2 * TILE_SIZE;
      const MAZE_ROWS = 12;
      const MAZE_COLS = 15;
      let start = [Math.floor(cheesyRandom(window.performance.now())*MAZE_COLS), 0];
      let finish = [Math.floor(cheesyRandom(window.performance.now())*MAZE_COLS), MAZE_ROWS-1];
      console.log(start);
      console.log(finish);

      // maze indexed [col,row] or [x,y]
      // top left cell is [0,0]

      // initially all walls are filled in
      var horizWalls = new Array(MAZE_COLS);
      for (var i = 0; i < horizWalls.length; i++) {
        horizWalls[i] = new Array(MAZE_ROWS+1);
        for (var j = 0; j < MAZE_ROWS+1; j++) {
          horizWalls[i][j] = true;
        }
      }
      var vertWalls = new Array(MAZE_COLS+1);
      for (var i = 0; i < vertWalls.length; i++) {
        vertWalls[i] = new Array(MAZE_ROWS);
        for (var j = 0; j < MAZE_ROWS; j++) {
          vertWalls[i][j] = true;
        }
      }

      // Statuses we keep for cells as we "dig" out path through maze
      const UNVISITED = 1;  // haven't been here yet
      const VISITED = 2;    // been here, but haven't tried all directions
      const DONE = 3;       // have looked in all directions
      var cellStatus = new Array(MAZE_COLS);
      for (var col = 0; col < cellStatus.length; col++) {
        cellStatus[col] = new Array(MAZE_ROWS);
        for (var row = 0; row < MAZE_ROWS; row++) {
          cellStatus[col][row] = UNVISITED;
        }
      }

      function getDigOrder() {
        // should randomize, maybe according to some parameters
        return ['U', 'D', 'L', 'R'];
      }

      function digCell(col, row) {
        console.log('From (' + col + ', ' + row + ')');
        let ordering = getDigOrder();
        cellStatus[col][row] = VISITED;
        for (let i = 0; i < 4; i++) {
          if (ordering[i] == 'U') {
            let digCol = col;
            let digRow = row-1;
            console.log('From (' + col + ', ' + row + '), ' + 'Dir ' + ordering[i] + ', checking cell (' + digCol + ', ' + digRow + ')')
            if (digRow >= 0 && cellStatus[digCol][digRow] == UNVISITED) {
              removeTopWall(col, row);
              digCell(digCol, digRow);
            }
          }
          if (ordering[i] == 'D') {
            let digCol = col;
            let digRow = row+1;
            console.log('From (' + col + ', ' + row + '), ' + 'Dir ' + ordering[i] + ', checking cell (' + digCol + ', ' + digRow + ')')
            if (digRow < MAZE_ROWS && cellStatus[digCol][digRow] == UNVISITED) {
              removeBottomWall(col, row);
              digCell(digCol, digRow);
            }
          }
          if (ordering[i] == 'L') {
            let digCol = col-1;
            let digRow = row;  
            console.log('From (' + col + ', ' + row + '), ' + 'Dir ' + ordering[i] + ', checking cell (' + digCol + ', ' + digRow + ')')
            if (digCol >= 0 && cellStatus[digCol][digRow] == UNVISITED) {
              removeLeftWall(col, row);
              digCell(digCol, digRow);
            }
          }
          if (ordering[i] == 'R') {
            let digCol = col+1;
            let digRow = row;
            console.log('From (' + col + ', ' + row + '), ' + 'Dir ' + ordering[i] + ', checking cell (' + digCol + ', ' + digRow + ')')
            if (digCol < MAZE_COLS && cellStatus[digCol][digRow] == UNVISITED) {
              removeRightWall(col, row);
              digCell(digCol, digRow);
            }
          }
        }
        cellStatus[col][row] = DONE;
        return;
      }

      function removeTopWall(col, row) {
        horizWalls[col][row] = 0;
      }

      function removeBottomWall(col, row) {
        horizWalls[col][row+1] = 0;
      }

      function removeLeftWall(col, row) {
        vertWalls[col][row] = 0;
      }

      function removeRightWall(col, row) {
        vertWalls[col+1][row] = 0;
      }

      function makeMaze() {
        removeTopWall(start[0], start[1]);
        removeBottomWall(finish[0], finish[1]);
        digCell(start[0], start[1]);
      }

      function makeAndDraw() {
        makeMaze();
        drawMaze();
      }

      // create path for downward-pointing arrow
      // centered at x,y  fits in box of size * size pixels
      function downArrow(x, y, size) {
        let u = Math.floor(size/6);  // "unit length"
        // start at top left of arrow's "stem" work around clockwise
        let pathString = 'M ' + x + ' ' + y;
        pathString = pathString + ' m ' + (-2*u) + ' ' + (-3*u);
        pathString = pathString + ' h ' + 4*u + ' v ' + 4*u + ' h ' + 2*u;
        pathString = pathString + ' l ' + (-4*u) + ' ' + 4*u + ' l ' + (-4*u) + ' ' + (-4*u);
        pathString = pathString + ' h ' + 2*u + ' Z';
        return new Path2D(pathString);
      }
      
      function drawMaze() {

        var canvas = document.getElementById('mazeFrame');
        var canvasWidth = canvas.width;
        var canvasHeight = canvas.height;
        if (canvas.getContext) {
          var ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          let startArrow = downArrow(start[0] * TILE_SIZE + TILE_SIZE/2, (TILE_SIZE), TILE_SIZE);
          ctx.fill(startArrow);
          let finishArrow = downArrow(finish[0] * TILE_SIZE + TILE_SIZE/2, TOP_MARGIN + (MAZE_ROWS+1) * TILE_SIZE, TILE_SIZE);
          ctx.fill(finishArrow);
          // draw walls, vert and horiz
          for (var row = 0; row < MAZE_ROWS; row += 1) {
            for (var col = 0; col < MAZE_COLS; col += 1) {
              // set x,y to top left of cell [col][row]
              var x = col * TILE_SIZE;
              var y = TOP_MARGIN + row * TILE_SIZE;
              if (horizWalls[col][row]) {
                ctx.beginPath();
                ctx.strokeStyle = '#000000';
                ctx.moveTo(x + 1, y);
                ctx.lineTo(x + TILE_SIZE-2, y);
                ctx.stroke();
              }
              if (vertWalls[col][row]) {
                ctx.beginPath();
                ctx.strokeStyle = '#000000';
                ctx.moveTo(x, y + 1);
                ctx.lineTo(x, y + TILE_SIZE-2);
                ctx.stroke();
              }
              // if in last col, may need to draw extra vert at end of row
              if (col == MAZE_COLS-1) {
                if (vertWalls[col+1][row]) {
                  ctx.beginPath();
                  ctx.strokeStyle = '#000000';
                  ctx.moveTo(x + TILE_SIZE, y + 1);
                  ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE-2);
                  ctx.stroke();
                }
              }
              // if in last row, may need to draw extra horiz at bottom of column
              if (row == MAZE_ROWS-1) {
                if (horizWalls[col][row+1]) {
                  ctx.beginPath();
                  ctx.strokeStyle = '#000000';
                  ctx.moveTo(x + 1, y + TILE_SIZE);
                  ctx.lineTo(x + TILE_SIZE-2, y + TILE_SIZE);
                  ctx.stroke();
                }
              }
            }
          }
        }
      }


      // low-budget 'random' generator
      // found this on Stack Overflow
      function cheesyRandom(seed) {
          var x = Math.sin(seed) * 1000000;
          return x - Math.floor(x);
      }


    </script>
    <style type="text/css">
      canvas { padding: 20px; }
      #main {
        background: #999;
        padding: 10px;
      }

      .frame {
        background: #ccc;
        /*height: 200px;*/
        margin: 20px;
      }
    </style>
  </head>


  <body onload="makeAndDraw();">
    <div id="main">
      <div class="frame">
        <canvas id="mazeFrame" width="800" height="490"></canvas>
      </div> 
    </div>
  </body>
</html>