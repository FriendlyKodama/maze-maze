<!-- Standalone basic maze using HTML Canvas-->

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>maze maze</title>
    <script type="text/javascript">
      const TILE_SIZE = 10;
      const TOP_MARGIN = 2 * TILE_SIZE;
      const LEFT_MARGIN = TILE_SIZE;
      // In recursive version:
      // 192x100 dies (stack overflow)
      // 191x100 ok
      // so max is about 19,000 cells
      // Non-recursive:
      // 2500x2500 runs fine, takes about 12 sec
      // max is > 6,250,000 cells
      // (on my machine)
      const MAZE_ROWS = 100;
      const MAZE_COLS = 100;
      let randomSeed = window.performance.now();
      let start = [Math.floor(cheesyRandom()*MAZE_COLS), 0];
      let finish = [Math.floor(cheesyRandom()*MAZE_COLS), MAZE_ROWS-1];

      // We will have patterns in the "flow"
      //let pattern = "random";
      let pattern = "checkered";
      //let pattern = "zigzag";

      let checkerSize = 20;
      let checkerPercent = 0.95;

      let zigzagSize = 10;
      let zigzagPercent = 0.98;

      // maze indexed [col,row] or [x,y]
      // top left cell is [0,0]

      // initially all walls are filled in
      var horizWalls = new Array(MAZE_COLS);
      for (var i = 0; i < horizWalls.length; i++) {
        horizWalls[i] = new Array(MAZE_ROWS+1);
        for (var j = 0; j < MAZE_ROWS+1; j++) {
          horizWalls[i][j] = true;
        }
      }
      var vertWalls = new Array(MAZE_COLS+1);
      for (var i = 0; i < vertWalls.length; i++) {
        vertWalls[i] = new Array(MAZE_ROWS);
        for (var j = 0; j < MAZE_ROWS; j++) {
          vertWalls[i][j] = true;
        }
      }

      let mazeTree = new Array();
      console.log("init, mt len: " + mazeTree.length);
      let mazeTreeCells = 0;

      // Statuses we keep for cells as we "dig" out path through maze
      const UNVISITED = 1;  // haven't been here yet
      const VISITED = 2;    // been here, but haven't tried all directions
      const DONE = 3;       // have looked in all directions
      var cellStatus = new Array(MAZE_COLS);
      for (var col = 0; col < cellStatus.length; col++) {
        cellStatus[col] = new Array(MAZE_ROWS);
        for (var row = 0; row < MAZE_ROWS; row++) {
          cellStatus[col][row] = UNVISITED;
        }
      }
      let depth = 0;

      function getDigOrder(col, row) {
        if (pattern == "random") {
          // randomly ordered
          let directions = ['U', 'D', 'L', 'R'];
          for (let i=0; i<3; i++) {
            let dir = directions[i];
            let j = randomBetween(i,3);
            directions[i] = directions[j];
            directions[j] = dir;       
            return directions;  
          } 
        } else if (pattern == "checkered") {
          // do a "checkered" pattern
          // prefer U/D or L/R in different regions
          let directions = ['U', 'D', 'L', 'R'];  // dummy vals for initialization
          let UD = (Math.random() > checkerPercent);
          if ((Math.floor(col/checkerSize) % 2)==(Math.floor(row/checkerSize) % 2)) {
            // prefer U/D in this checkered square
            UD = (Math.random() < checkerPercent);
          }
          if (!UD) {
            // Swap U,D for L, R
            directions = ['L', 'R', 'U', 'D'];
          }
          // now randomly choose L vs R, U vs D by swapping
          if (Math.random() < 0.5) {
            let temp = directions[0];
            directions[0] = directions[1];
            directions[1] = temp;
          }
          if (Math.random() < 0.5) {
            let temp = directions[2];
            directions[2] = directions[3];
            directions[3] = temp;
          }
          return directions;
        } else if (pattern == "zigzag") {
          // do a "zigzag" pattern
          // prefer U/D or L/R in different diagonal stripes
          let directions = ['U', 'D', 'L', 'R'];  // dummy vals for initialization
          let UD = (Math.random() > zigzagPercent);
          if ((Math.floor((col+row)/(2*zigzagSize)) % 2) == 0) {
            // prefer U/D in this diagonal stripe
            UD = (Math.random() < zigzagPercent);
          }
          if (!UD) {
            // Swap U,D for L, R
            directions = ['L', 'R', 'U', 'D'];
          }
          // now randomly choose L vs R, U vs D by swapping
          if (Math.random() < 0.5) {
            let temp = directions[0];
            directions[0] = directions[1];
            directions[1] = temp;
          }
          if (Math.random() < 0.5) {
            let temp = directions[2];
            directions[2] = directions[3];
            directions[3] = temp;
          }
          return directions;
        }
      }

      function printMazeTree() {
        console.log("-------------------------------");
        for (let i=0; i<mazeTree.length; i++) {
          //console.log("mt[" + i + "]" + mazeTree[i]);
          console.log(mazeTree[i]);
        }
      }

      // starting at (col, row),
      // "dig" through the grid, creating mazeTree[] through cells
      function digMaze(col, row) {
        //console.log("digging at : " + col + ", " + row);
        let depth = 0;
        let numCellsDone = 0;
        let numCellsDug = 0;
        let currentCell = 0;  // index into mazeTree[]
        mazeTree.push({'col': col, 'row': row, 'parent': -1, 'digOrder': getDigOrder(col, row), 'digs': 0, 'depth':depth});
        cellStatus[col][row] = VISITED;
        numCellsDug = 1;

        // each time through the loop:
        // we pick an already-VISITED (but not DONE) cell and dig in a new direction
        // if no direction is available, then mark DONE
        // end-of-loop invariants
        //   mazeTree[] up-to-date and consistent
        //   if cell is DONE, so are all children, out to leaves
        while (numCellsDone < MAZE_ROWS*MAZE_COLS) {
          //console.log("cc: " + currentCell + " mazetree len: " + mazeTree.length);
          //console.log("cellsDone: " + numCellsDone + ", cells dug: " + numCellsDug);
          //printMazeTree();
          let row = mazeTree[currentCell].row;
          let digs = mazeTree[currentCell].digs;
          let digOrder = mazeTree[currentCell].digOrder;
          let dir = digOrder[digs];
          let depth = mazeTree[currentCell].depth;
          //console.log("cur: " + currentCell + ", dir: " + dir + ", digs: " + digs + ", depth: " + depth);
          // get a direction, see if we can dig
          if (dir == 'U') {
            col = mazeTree[currentCell].col;  //
            row = mazeTree[currentCell].row;  //
            //console.log("Testing U from: (" + col + "," + row + ")");
            mazeTree[currentCell].digs += 1;
            let digCol = col;
            let digRow = row-1;
            if (digRow >= 0 && cellStatus[digCol][digRow] == UNVISITED) {
              removeTopWall(col, row);
              //console.log("Digging U to: (" + digCol + "," + digRow + ")");
              mazeTree.push({'col': digCol, 'row': digRow, 'parent': currentCell, 'digs': 0, 'digOrder': getDigOrder(col, row), 'depth': depth+1});
              cellStatus[digCol][digRow] = VISITED;
              numCellsDug += 1;
              currentCell = mazeTree.length-1;
            }
          } else if (dir == 'D') {
            col = mazeTree[currentCell].col;  //
            row = mazeTree[currentCell].row;  //
            //console.log("Testing D from: (" + col + "," + row + ")");
            mazeTree[currentCell].digs += 1;
            let digCol = col;
            let digRow = row+1;
            if (digRow < MAZE_ROWS && cellStatus[digCol][digRow] == UNVISITED) {
              removeBottomWall(col, row);
              //console.log("Digging D to: (" + digCol + "," + digRow + ")");
              mazeTree.push({'col': digCol, 'row': digRow, 'parent': currentCell, 'digs': 0, 'digOrder': getDigOrder(col, row), 'depth': depth+1});
              cellStatus[digCol][digRow] = VISITED;
              numCellsDug += 1;
              currentCell = mazeTree.length-1;
            }
          } else if (dir == 'L') {
            col = mazeTree[currentCell].col;  //
            row = mazeTree[currentCell].row;  //
            //console.log("Testing L from: (" + col + "," + row + ")");
            mazeTree[currentCell].digs += 1;
            let digCol = col-1;
            let digRow = row;  
            if (digCol >= 0 && cellStatus[digCol][digRow] == UNVISITED) {
              removeLeftWall(col, row);
              //console.log("Digging L to: (" + digCol + "," + digRow + ")");
              mazeTree.push({'col': digCol, 'row': digRow, 'parent': currentCell, 'digs': 0, 'digOrder': getDigOrder(col, row), 'depth': depth+1});
              cellStatus[digCol][digRow] = VISITED;
              numCellsDug += 1;
              currentCell = mazeTree.length-1;
            }
          } else if (dir == 'R') {
            col = mazeTree[currentCell].col;  //
            row = mazeTree[currentCell].row;  //
            //console.log("Testing R from: (" + col + "," + row + ")");
            mazeTree[currentCell].digs += 1;
            let digCol = col+1;
            let digRow = row;
            if (digCol < MAZE_COLS && cellStatus[digCol][digRow] == UNVISITED) {
              removeRightWall(col, row);
              //console.log("Digging R to: (" + digCol + "," + digRow + ")");
              mazeTree.push({'col': digCol, 'row': digRow, 'parent': currentCell, 'digs': 0, 'digOrder': getDigOrder(col, row), 'depth': depth+1});
              cellStatus[digCol][digRow] = VISITED;
              numCellsDug += 1;
              currentCell = mazeTree.length-1;
            }
          }
          // this will only happen after trying all 4 directions from this cell
          if (mazeTree[currentCell].digs == 4) {
            col = mazeTree[currentCell].col;
            row = mazeTree[currentCell].row;
            //console.log("backtracking from: (" + col + "," + row + ")");
            cellStatus[mazeTree[currentCell].col][mazeTree[currentCell].row] = DONE;
            numCellsDone += 1;
            if (mazeTree[currentCell].parent == -1) {
              console.log("should be done!");
            } else {
              currentCell = mazeTree[currentCell].parent;
              col = mazeTree[currentCell].col;
              row = mazeTree[currentCell].row;
              //console.log("  backtracked to: (" + col + "," + row + ")");
              //printMazeTree();
            }
          }
        }
      }

      function removeTopWall(col, row) {
        horizWalls[col][row] = 0;
      }

      function removeBottomWall(col, row) {
        horizWalls[col][row+1] = 0;
      }

      function removeLeftWall(col, row) {
        vertWalls[col][row] = 0;
      }

      function removeRightWall(col, row) {
        vertWalls[col+1][row] = 0;
      }

      function makeMaze() {
        removeTopWall(start[0], start[1]);
        removeBottomWall(finish[0], finish[1]);
        digMaze(start[0], start[1]);
      }

      function makeAndDraw() {
        makeMaze();
        drawMaze();
      }

      // create path for downward-pointing arrow
      // centered at x,y  fits in box of size * size pixels
      function downArrow(x, y, size) {
        let u = Math.floor(size/6);  // "unit length"
        // start at top left of arrow's "stem" work around clockwise
        let pathString = 'M ' + x + ' ' + y;
        pathString = pathString + ' m ' + (-2*u) + ' ' + (-3*u);
        pathString = pathString + ' h ' + 4*u + ' v ' + 4*u + ' h ' + 2*u;
        pathString = pathString + ' l ' + (-4*u) + ' ' + 4*u + ' l ' + (-4*u) + ' ' + (-4*u);
        pathString = pathString + ' h ' + 2*u + ' Z';
        return new Path2D(pathString);
      }
      
      function drawMaze() {

        var canvas = document.getElementById('mazeFrame');
        var canvasWidth = canvas.width;
        var canvasHeight = canvas.height;
        if (canvas.getContext) {
          var ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          let startArrow = downArrow(LEFT_MARGIN + start[0] * TILE_SIZE + TILE_SIZE/2, (TILE_SIZE), TILE_SIZE);
          ctx.fill(startArrow);
          let finishArrow = downArrow(LEFT_MARGIN + finish[0] * TILE_SIZE + TILE_SIZE/2, TOP_MARGIN + (MAZE_ROWS+1) * TILE_SIZE, TILE_SIZE);
          ctx.fill(finishArrow);
          // draw walls, vert and horiz
          for (var row = 0; row < MAZE_ROWS; row += 1) {
            for (var col = 0; col < MAZE_COLS; col += 1) {
              // set x,y to top left of cell [col][row]
              var x = LEFT_MARGIN + col * TILE_SIZE;
              var y = TOP_MARGIN + row * TILE_SIZE;
              if (horizWalls[col][row]) {
                ctx.beginPath();
                ctx.strokeStyle = '#000000';
                ctx.moveTo(x, y);
                ctx.lineTo(x + TILE_SIZE, y);
                ctx.stroke();
              }
              if (vertWalls[col][row]) {
                ctx.beginPath();
                ctx.strokeStyle = '#000000';
                ctx.moveTo(x, y);
                ctx.lineTo(x, y + TILE_SIZE);
                ctx.stroke();
              }
              // if in last col, may need to draw extra vert at end of row
              if (col == MAZE_COLS-1) {
                if (vertWalls[col+1][row]) {
                  ctx.beginPath();
                  ctx.strokeStyle = '#000000';
                  ctx.moveTo(x + TILE_SIZE, y);
                  ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE);
                  ctx.stroke();
                }
              }
              // if in last row, may need to draw extra horiz at bottom of column
              if (row == MAZE_ROWS-1) {
                if (horizWalls[col][row+1]) {
                  ctx.beginPath();
                  ctx.strokeStyle = '#000000';
                  ctx.moveTo(x, y + TILE_SIZE);
                  ctx.lineTo(x + TILE_SIZE, y + TILE_SIZE);
                  ctx.stroke();
                }
              }
            }
          }
        }
      }


      // low-budget 'random' generator
      // found this on Stack Overflow
      // could cycle
      function cheesyRandom() {
          randomSeed = Math.sin(randomSeed) * 1000000;
          return randomSeed - Math.floor(randomSeed);
      }
      // integer between lo, hi, inclusive
      function randomBetween(lo, hi) {
        return Math.floor(lo + cheesyRandom()*(1+hi-lo));
      }

    </script>
    <style type="text/css">
      canvas { padding: 20px; }
      #main {
        background: #999;
        padding: 10px;
      }

      .frame {
        background: #ccc;
        /*height: 200px;*/
        margin: 20px;
      }
    </style>
  </head>


  <!-- need to set canvas size based on #rows and cols -->
  <body onload="makeAndDraw();">
    <div id="main">
      <div class="frame">
        <div class="maze">
          <canvas id="mazeFrame" width="1000" height="800"></canvas>
        </div>
        <div class="controls">
          controls could go here
        </div>
      </div> 
    </div>
  </body>
</html>